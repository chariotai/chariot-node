/* tslint:disable */
/* eslint-disable */
/**
 * Chariot API
 * API for interacting with various language models.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Main Application model
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * Timestamp of when the application was created.
     * @type {string}
     * @memberof Application
     */
    'created_at'?: string;
    /**
     * Description of the application.
     * @type {string}
     * @memberof Application
     */
    'description'?: string;
    /**
     * Unique identifier for the application.
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * 
     * @type {LanguageModel}
     * @memberof Application
     */
    'model'?: LanguageModel;
    /**
     * Name of the application.
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * Directions for the language model to follow when generating completions. Included in each conversation.
     * @type {string}
     * @memberof Application
     */
    'system_message'?: string;
    /**
     * Timestamp of when the application was last updated.
     * @type {string}
     * @memberof Application
     */
    'updated_at'?: string;
}


/**
 * Main Conversation model
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * Unique identifier for the application this conversation is associated with.
     * @type {string}
     * @memberof Conversation
     */
    'application_id'?: string;
    /**
     * Total number of completion tokens used by the convesation.
     * @type {number}
     * @memberof Conversation
     */
    'completion_tokens'?: number;
    /**
     * Timestamp of when the conversation was created.
     * @type {string}
     * @memberof Conversation
     */
    'created_at'?: string;
    /**
     * Unique identifier for the conversation.
     * @type {string}
     * @memberof Conversation
     */
    'id'?: string;
    /**
     * List of messages in the conversation.
     * @type {Array<Message>}
     * @memberof Conversation
     */
    'messages'?: Array<Message>;
    /**
     * Total number of prompt tokens used by the convesation.
     * @type {number}
     * @memberof Conversation
     */
    'prompt_tokens'?: number;
    /**
     * Title of the conversation. This is auto generated by the language model at creation time based on the context of the first message and can be updated.
     * @type {string}
     * @memberof Conversation
     */
    'title'?: string;
    /**
     * Total tokens used by the convesation.
     * @type {number}
     * @memberof Conversation
     */
    'total_tokens'?: number;
    /**
     * Timestamp of when the conversation was last updated.
     * @type {string}
     * @memberof Conversation
     */
    'updated_at'?: string;
}
/**
 * Conversation response
 * @export
 * @interface ConversationResponse
 */
export interface ConversationResponse {
    /**
     * Unique identifier for the conversation.
     * @type {string}
     * @memberof ConversationResponse
     */
    'id': string;
    /**
     * Response message generated by the language model.
     * @type {string}
     * @memberof ConversationResponse
     */
    'message': string;
    /**
     * List of sources used by the language model to generate the response message.
     * @type {Array<MessageSource>}
     * @memberof ConversationResponse
     */
    'sources'?: Array<MessageSource>;
    /**
     * Title of the conversation.
     * @type {string}
     * @memberof ConversationResponse
     */
    'title': string;
}
/**
 * Create application model
 * @export
 * @interface CreateApplication
 */
export interface CreateApplication {
    /**
     * Description of the application.
     * @type {string}
     * @memberof CreateApplication
     */
    'description'?: string;
    /**
     * 
     * @type {LanguageModel}
     * @memberof CreateApplication
     */
    'model'?: LanguageModel;
    /**
     * Name of the application.
     * @type {string}
     * @memberof CreateApplication
     */
    'name': string;
    /**
     * Directions for the language model to follow when generating completions. Included in each conversation.
     * @type {string}
     * @memberof CreateApplication
     */
    'system_message'?: string;
}


/**
 * Create conversation model
 * @export
 * @interface CreateOrContinueConversation
 */
export interface CreateOrContinueConversation {
    /**
     * Unique identifier for the application this conversation is associated with. This field is required when starting a new conversation.
     * @type {string}
     * @memberof CreateOrContinueConversation
     */
    'application_id'?: string;
    /**
     * Unique identifier for the conversation. If not provided, a new conversation will be created.
     * @type {string}
     * @memberof CreateOrContinueConversation
     */
    'conversation_id'?: string;
    /**
     * Message to start or continue the conversation with.
     * @type {string}
     * @memberof CreateOrContinueConversation
     */
    'message': string;
    /**
     * If true, the response will be streamed using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
     * @type {boolean}
     * @memberof CreateOrContinueConversation
     */
    'stream'?: boolean;
}
/**
 * Create source request
 * @export
 * @interface CreateSource
 */
export interface CreateSource {
    /**
     * Unique identifier for the application this source should be associated with.
     * @type {string}
     * @memberof CreateSource
     */
    'application_id': string;
    /**
     * Source content. This can be text, a list of URLs to crawl, or a file.
     * @type {any}
     * @memberof CreateSource
     */
    'content': any;
    /**
     * Name of the source. Used when displaying where information came from in a conversation.
     * @type {string}
     * @memberof CreateSource
     */
    'name': string;
    /**
     * Type of source. Used to determine how to process the source.
     * @type {string}
     * @memberof CreateSource
     */
    'type': string;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EmbedStatus = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Error: 'ERROR'
} as const;

export type EmbedStatus = typeof EmbedStatus[keyof typeof EmbedStatus];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const LanguageModel = {
    _35Turbo: 'gpt-3.5-turbo',
    _4: 'gpt-4'
} as const;

export type LanguageModel = typeof LanguageModel[keyof typeof LanguageModel];


/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * Base message
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'role': string;
    /**
     * 
     * @type {Array<MessageSource>}
     * @memberof Message
     */
    'sources'?: Array<MessageSource>;
}
/**
 * Source
 * @export
 * @interface MessageSource
 */
export interface MessageSource {
    /**
     * 
     * @type {number}
     * @memberof MessageSource
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageSource
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof MessageSource
     */
    'source': string;
}
/**
 * 
 * @export
 * @interface ResponseCreateSource
 */
export interface ResponseCreateSource {
    /**
     * Unique identifier for the application this source is associated with.
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'application_id': string;
    /**
     * Source content. This can be text, a list of URLs to crawl, or a file.
     * @type {any}
     * @memberof ResponseCreateSource
     */
    'content': any;
    /**
     * Timestamp of when the source was created.
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'created_at': string;
    /**
     * 
     * @type {EmbedStatus}
     * @memberof ResponseCreateSource
     */
    'embed_status'?: EmbedStatus;
    /**
     * Optional message associated with the `embed_status`. If there is an error processing the source, this field will contain the error message.
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'embed_status_message'?: string;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'id': string;
    /**
     * Name of the source. Used when displaying where information came from in a conversation.
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'name': string;
    /**
     * Type of source. Used to determine how to process the source.
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'type': string;
    /**
     * Timestamp of when the source was last updated
     * @type {string}
     * @memberof ResponseCreateSource
     */
    'updated_at': string;
}


/**
 * Represents data associated with an application (file, URL, raw text, etc.) Each source gets processed, embedded, and stored in Pinecone
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Unique identifier for the application this source is associated with.
     * @type {string}
     * @memberof Source
     */
    'application_id': string;
    /**
     * Source content. This can be text, a list of URLs to crawl, or a file.
     * @type {any}
     * @memberof Source
     */
    'content': any;
    /**
     * Timestamp of when the source was created.
     * @type {string}
     * @memberof Source
     */
    'created_at': string;
    /**
     * 
     * @type {EmbedStatus}
     * @memberof Source
     */
    'embed_status'?: EmbedStatus;
    /**
     * Optional message associated with the `embed_status`. If there is an error processing the source, this field will contain the error message.
     * @type {string}
     * @memberof Source
     */
    'embed_status_message'?: string;
    /**
     * Unique identifier for the source
     * @type {string}
     * @memberof Source
     */
    'id': string;
    /**
     * Name of the source. Used when displaying where information came from in a conversation.
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * Type of source. Used to determine how to process the source.
     * @type {string}
     * @memberof Source
     */
    'type': string;
    /**
     * Timestamp of when the source was last updated
     * @type {string}
     * @memberof Source
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface Sources
 */
export interface Sources {
    /**
     * Unique identifier for the application this source should be associated with.
     * @type {string}
     * @memberof Sources
     */
    'application_id': string;
    /**
     * Source content. This can be text, a list of URLs to crawl, or a file.
     * @type {any}
     * @memberof Sources
     */
    'content': any;
    /**
     * Name of the source. Used when displaying where information came from in a conversation.
     * @type {string}
     * @memberof Sources
     */
    'name': string;
    /**
     * Type of source. Used to determine how to process the source.
     * @type {string}
     * @memberof Sources
     */
    'type': string;
}
/**
 * Application update model, represents the updatable fields of an application
 * @export
 * @interface UpdateApplication
 */
export interface UpdateApplication {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplication
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplication
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplication
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplication
     */
    'system_message'?: string;
}
/**
 * Update conversation model, represents the updatable fields of a conversation
 * @export
 * @interface UpdateConversation
 */
export interface UpdateConversation {
    /**
     * 
     * @type {string}
     * @memberof UpdateConversation
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * ChariotApi - axios parameter creator
 * @export
 */
export const ChariotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new application with the specified settings.
         * @summary Create application
         * @param {CreateApplication} createApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplication: CreateApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplication' is not null or undefined
            assertParamExists('createApplication', 'createApplication', createApplication)
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
         * @summary Create or continue conversation
         * @param {CreateOrContinueConversation} createOrContinueConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrContinueConversation: async (createOrContinueConversation: CreateOrContinueConversation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrContinueConversation' is not null or undefined
            assertParamExists('createOrContinueConversation', 'createOrContinueConversation', createOrContinueConversation)
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrContinueConversation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new source. You can create multiple sources at once by passing an array of sources.
         * @summary Create source
         * @param {Sources} sources 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sources: Sources, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sources' is not null or undefined
            assertParamExists('createSource', 'sources', sources)
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sources, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes an application and all related conversations and sources. This cannot be undone.
         * @summary Delete application
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplication', 'id', id)
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
         * @summary Delete application sources
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSources: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationSources', 'id', id)
            const localVarPath = `/applications/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a conversation and all related messages. This cannot be undone.
         * @summary Delete conversation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationConversationsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConversationConversationsIdDelete', 'id', id)
            const localVarPath = `/conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes the specified source. This cannot be undone.
         * @summary Delete source
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single application.
         * @summary Get application
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplication', 'id', id)
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single conversation, including all messages.
         * @summary Get conversation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConversation', 'id', id)
            const localVarPath = `/conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single source.
         * @summary Get source
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSource', 'id', id)
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
         * @summary List application conversations
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationConversations: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listApplicationConversations', 'id', id)
            const localVarPath = `/applications/{id}/conversations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all sources associated with the specified application.
         * @summary List application sources
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSources: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listApplicationSources', 'id', id)
            const localVarPath = `/applications/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
         * @summary List conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
         * @summary List sources
         * @param {string} [applicationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (applicationId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applicationId !== undefined) {
                localVarQueryParameter['application_id'] = applicationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified application.
         * @summary Update application
         * @param {string} id 
         * @param {UpdateApplication} updateApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (id: string, updateApplication: UpdateApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateApplication', 'id', id)
            // verify required parameter 'updateApplication' is not null or undefined
            assertParamExists('updateApplication', 'updateApplication', updateApplication)
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specifed conversation.
         * @summary Update conversation
         * @param {string} id 
         * @param {UpdateConversation} updateConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation: async (id: string, updateConversation: UpdateConversation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateConversation', 'id', id)
            // verify required parameter 'updateConversation' is not null or undefined
            assertParamExists('updateConversation', 'updateConversation', updateConversation)
            const localVarPath = `/conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConversation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChariotApi - functional programming interface
 * @export
 */
export const ChariotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChariotApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new application with the specified settings.
         * @summary Create application
         * @param {CreateApplication} createApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplication: CreateApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplication, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
         * @summary Create or continue conversation
         * @param {CreateOrContinueConversation} createOrContinueConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrContinueConversation(createOrContinueConversation: CreateOrContinueConversation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrContinueConversation(createOrContinueConversation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new source. You can create multiple sources at once by passing an array of sources.
         * @summary Create source
         * @param {Sources} sources 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sources: Sources, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sources, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes an application and all related conversations and sources. This cannot be undone.
         * @summary Delete application
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
         * @summary Delete application sources
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationSources(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationSources(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a conversation and all related messages. This cannot be undone.
         * @summary Delete conversation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationConversationsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversationConversationsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes the specified source. This cannot be undone.
         * @summary Delete source
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a single application.
         * @summary Get application
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a single conversation, including all messages.
         * @summary Get conversation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a single source.
         * @summary Get source
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSource(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSource(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
         * @summary List application conversations
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationConversations(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conversation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationConversations(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all sources associated with the specified application.
         * @summary List application sources
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationSources(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationSources(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
         * @summary List conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conversation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
         * @summary List sources
         * @param {string} [applicationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(applicationId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSources(applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readRootGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readRootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified application.
         * @summary Update application
         * @param {string} id 
         * @param {UpdateApplication} updateApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(id: string, updateApplication: UpdateApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(id, updateApplication, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specifed conversation.
         * @summary Update conversation
         * @param {string} id 
         * @param {UpdateConversation} updateConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversation(id: string, updateConversation: UpdateConversation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversation(id, updateConversation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChariotApi - factory interface
 * @export
 */
export const ChariotApiFactory = function (apiKey: string, basePath?: string, axios?: AxiosInstance) {
    const configuration = new Configuration({apiKey})
    const localVarFp = ChariotApiFp(configuration)
    return {
        /**
         * Creates a new application with the specified settings.
         * @summary Create application
         * @param {CreateApplication} createApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplication: CreateApplication, options?: any): AxiosPromise<Application> {
            return localVarFp.createApplication(createApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
         * @summary Create or continue conversation
         * @param {CreateOrContinueConversation} createOrContinueConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrContinueConversation(createOrContinueConversation: CreateOrContinueConversation, options?: any): AxiosPromise<ConversationResponse> {
            return localVarFp.createOrContinueConversation(createOrContinueConversation, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new source. You can create multiple sources at once by passing an array of sources.
         * @summary Create source
         * @param {Sources} sources 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sources: Sources, options?: any): AxiosPromise<ResponseCreateSource> {
            return localVarFp.createSource(sources, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an application and all related conversations and sources. This cannot be undone.
         * @summary Delete application
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
         * @summary Delete application sources
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSources(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationSources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a conversation and all related messages. This cannot be undone.
         * @summary Delete conversation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationConversationsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConversationConversationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the specified source. This cannot be undone.
         * @summary Delete source
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single application.
         * @summary Get application
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(id: string, options?: any): AxiosPromise<Application> {
            return localVarFp.getApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single conversation, including all messages.
         * @summary Get conversation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(id: string, options?: any): AxiosPromise<Conversation> {
            return localVarFp.getConversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single source.
         * @summary Get source
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id: string, options?: any): AxiosPromise<Source> {
            return localVarFp.getSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
         * @summary List application conversations
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationConversations(id: string, options?: any): AxiosPromise<Array<Conversation>> {
            return localVarFp.listApplicationConversations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all sources associated with the specified application.
         * @summary List application sources
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSources(id: string, options?: any): AxiosPromise<Array<Source>> {
            return localVarFp.listApplicationSources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(options?: any): AxiosPromise<Array<Application>> {
            return localVarFp.listApplications(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
         * @summary List conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations(options?: any): AxiosPromise<Array<Conversation>> {
            return localVarFp.listConversations(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
         * @summary List sources
         * @param {string} [applicationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(applicationId?: string, options?: any): AxiosPromise<Array<Source>> {
            return localVarFp.listSources(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet(options?: any): AxiosPromise<any> {
            return localVarFp.readRootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified application.
         * @summary Update application
         * @param {string} id 
         * @param {UpdateApplication} updateApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(id: string, updateApplication: UpdateApplication, options?: any): AxiosPromise<Application> {
            return localVarFp.updateApplication(id, updateApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specifed conversation.
         * @summary Update conversation
         * @param {string} id 
         * @param {UpdateConversation} updateConversation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(id: string, updateConversation: UpdateConversation, options?: any): AxiosPromise<Conversation> {
            return localVarFp.updateConversation(id, updateConversation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChariotApi - object-oriented interface
 * @export
 * @class ChariotApi
 * @extends {BaseAPI}
 */
export class ChariotApi extends BaseAPI {
    /**
     * Creates a new application with the specified settings.
     * @summary Create application
     * @param {CreateApplication} createApplication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public createApplication(createApplication: CreateApplication, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).createApplication(createApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
     * @summary Create or continue conversation
     * @param {CreateOrContinueConversation} createOrContinueConversation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public createOrContinueConversation(createOrContinueConversation: CreateOrContinueConversation, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).createOrContinueConversation(createOrContinueConversation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new source. You can create multiple sources at once by passing an array of sources.
     * @summary Create source
     * @param {Sources} sources 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public createSource(sources: Sources, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).createSource(sources, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes an application and all related conversations and sources. This cannot be undone.
     * @summary Delete application
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public deleteApplication(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).deleteApplication(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
     * @summary Delete application sources
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public deleteApplicationSources(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).deleteApplicationSources(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a conversation and all related messages. This cannot be undone.
     * @summary Delete conversation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public deleteConversationConversationsIdDelete(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).deleteConversationConversationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes the specified source. This cannot be undone.
     * @summary Delete source
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public deleteSource(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).deleteSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single application.
     * @summary Get application
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public getApplication(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).getApplication(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single conversation, including all messages.
     * @summary Get conversation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public getConversation(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).getConversation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single source.
     * @summary Get source
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public getSource(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).getSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
     * @summary List application conversations
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public listApplicationConversations(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).listApplicationConversations(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all sources associated with the specified application.
     * @summary List application sources
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public listApplicationSources(id: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).listApplicationSources(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your applications.
     * @summary List applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public listApplications(options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).listApplications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
     * @summary List conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public listConversations(options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).listConversations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
     * @summary List sources
     * @param {string} [applicationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public listSources(applicationId?: string, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).listSources(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public readRootGet(options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).readRootGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified application.
     * @summary Update application
     * @param {string} id 
     * @param {UpdateApplication} updateApplication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public updateApplication(id: string, updateApplication: UpdateApplication, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).updateApplication(id, updateApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specifed conversation.
     * @summary Update conversation
     * @param {string} id 
     * @param {UpdateConversation} updateConversation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    public updateConversation(id: string, updateConversation: UpdateConversation, options?: AxiosRequestConfig) {
        return ChariotApiFp(this.configuration).updateConversation(id, updateConversation, options).then((request) => request(this.axios, this.basePath));
    }
}


