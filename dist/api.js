"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Chariot API
 * API for interacting with various language models.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChariotApi = exports.ChariotApiFactory = exports.ChariotApiFp = exports.ChariotApiAxiosParamCreator = exports.LanguageModel = exports.EmbedStatus = void 0;
const configuration_1 = require("./configuration");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
exports.EmbedStatus = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Error: 'ERROR'
};
/**
 * An enumeration.
 * @export
 * @enum {string}
 */
exports.LanguageModel = {
    _35Turbo: 'gpt-3.5-turbo',
    _4: 'gpt-4'
};
/**
 * ChariotApi - axios parameter creator
 * @export
 */
exports.ChariotApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new application with the specified settings.
         * @summary Create application
         * @param {CreateApplication} createApplication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: (createApplication, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createApplication' is not null or undefined
            common_1.assertParamExists('createApplication', 'createApplication', createApplication);
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createApplication, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
         * @summary Create or continue conversation
         * @param {CreateOrContinueConversation} createOrContinueConversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrContinueConversation: (createOrContinueConversation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'createOrContinueConversation' is not null or undefined
            common_1.assertParamExists('createOrContinueConversation', 'createOrContinueConversation', createOrContinueConversation);
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(createOrContinueConversation, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new source. You can create multiple sources at once by passing an array of sources.
         * @summary Create source
         * @param {Sources} sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: (sources, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'sources' is not null or undefined
            common_1.assertParamExists('createSource', 'sources', sources);
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sources, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes an application and all related conversations and sources. This cannot be undone.
         * @summary Delete application
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('deleteApplication', 'id', id);
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
         * @summary Delete application sources
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSources: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('deleteApplicationSources', 'id', id);
            const localVarPath = `/applications/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes a conversation and all related messages. This cannot be undone.
         * @summary Delete conversation
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationConversationsIdDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('deleteConversationConversationsIdDelete', 'id', id);
            const localVarPath = `/conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Permanently deletes the specified source. This cannot be undone.
         * @summary Delete source
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('deleteSource', 'id', id);
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single application.
         * @summary Get application
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getApplication', 'id', id);
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single conversation, including all messages.
         * @summary Get conversation
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getConversation', 'id', id);
            const localVarPath = `/conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single source.
         * @summary Get source
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getSource', 'id', id);
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
         * @summary List application conversations
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationConversations: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('listApplicationConversations', 'id', id);
            const localVarPath = `/applications/{id}/conversations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of all sources associated with the specified application.
         * @summary List application sources
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSources: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('listApplicationSources', 'id', id);
            const localVarPath = `/applications/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of your applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
         * @summary List conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
         * @summary List sources
         * @param {string} [applicationId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources: (applicationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (applicationId !== undefined) {
                localVarQueryParameter['application_id'] = applicationId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the specified application.
         * @summary Update application
         * @param {string} id
         * @param {UpdateApplication} updateApplication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: (id, updateApplication, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('updateApplication', 'id', id);
            // verify required parameter 'updateApplication' is not null or undefined
            common_1.assertParamExists('updateApplication', 'updateApplication', updateApplication);
            const localVarPath = `/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateApplication, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the specifed conversation.
         * @summary Update conversation
         * @param {string} id
         * @param {UpdateConversation} updateConversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation: (id, updateConversation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('updateConversation', 'id', id);
            // verify required parameter 'updateConversation' is not null or undefined
            common_1.assertParamExists('updateConversation', 'updateConversation', updateConversation);
            const localVarPath = `/conversations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(updateConversation, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ChariotApi - functional programming interface
 * @export
 */
exports.ChariotApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ChariotApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates a new application with the specified settings.
         * @summary Create application
         * @param {CreateApplication} createApplication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplication, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApplication(createApplication, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
         * @summary Create or continue conversation
         * @param {CreateOrContinueConversation} createOrContinueConversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrContinueConversation(createOrContinueConversation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrContinueConversation(createOrContinueConversation, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Creates a new source. You can create multiple sources at once by passing an array of sources.
         * @summary Create source
         * @param {Sources} sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sources, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSource(sources, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Permanently deletes an application and all related conversations and sources. This cannot be undone.
         * @summary Delete application
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplication(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
         * @summary Delete application sources
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSources(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplicationSources(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Permanently deletes a conversation and all related messages. This cannot be undone.
         * @summary Delete conversation
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationConversationsIdDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteConversationConversationsIdDelete(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Permanently deletes the specified source. This cannot be undone.
         * @summary Delete source
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSource(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieves a single application.
         * @summary Get application
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getApplication(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieves a single conversation, including all messages.
         * @summary Get conversation
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConversation(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieves a single source.
         * @summary Get source
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSource(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
         * @summary List application conversations
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationConversations(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicationConversations(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of all sources associated with the specified application.
         * @summary List application sources
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSources(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicationSources(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of your applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplications(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
         * @summary List conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listConversations(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
         * @summary List sources
         * @param {string} [applicationId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(applicationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSources(applicationId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.readRootGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Updates the specified application.
         * @summary Update application
         * @param {string} id
         * @param {UpdateApplication} updateApplication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(id, updateApplication, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateApplication(id, updateApplication, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Updates the specifed conversation.
         * @summary Update conversation
         * @param {string} id
         * @param {UpdateConversation} updateConversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(id, updateConversation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateConversation(id, updateConversation, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ChariotApi - factory interface
 * @export
 */
exports.ChariotApiFactory = function (apiKey, basePath, axios) {
    const configuration = new configuration_1.Configuration({ apiKey });
    const localVarFp = exports.ChariotApiFp(configuration);
    return {
        /**
         * Creates a new application with the specified settings.
         * @summary Create application
         * @param {CreateApplication} createApplication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplication, options) {
            return localVarFp.createApplication(createApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
         * @summary Create or continue conversation
         * @param {CreateOrContinueConversation} createOrContinueConversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrContinueConversation(createOrContinueConversation, options) {
            return localVarFp.createOrContinueConversation(createOrContinueConversation, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new source. You can create multiple sources at once by passing an array of sources.
         * @summary Create source
         * @param {Sources} sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sources, options) {
            return localVarFp.createSource(sources, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an application and all related conversations and sources. This cannot be undone.
         * @summary Delete application
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(id, options) {
            return localVarFp.deleteApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
         * @summary Delete application sources
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationSources(id, options) {
            return localVarFp.deleteApplicationSources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a conversation and all related messages. This cannot be undone.
         * @summary Delete conversation
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationConversationsIdDelete(id, options) {
            return localVarFp.deleteConversationConversationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes the specified source. This cannot be undone.
         * @summary Delete source
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id, options) {
            return localVarFp.deleteSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single application.
         * @summary Get application
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(id, options) {
            return localVarFp.getApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single conversation, including all messages.
         * @summary Get conversation
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(id, options) {
            return localVarFp.getConversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single source.
         * @summary Get source
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(id, options) {
            return localVarFp.getSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
         * @summary List application conversations
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationConversations(id, options) {
            return localVarFp.listApplicationConversations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all sources associated with the specified application.
         * @summary List application sources
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationSources(id, options) {
            return localVarFp.listApplicationSources(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your applications.
         * @summary List applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(options) {
            return localVarFp.listApplications(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
         * @summary List conversations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations(options) {
            return localVarFp.listConversations(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
         * @summary List sources
         * @param {string} [applicationId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(applicationId, options) {
            return localVarFp.listSources(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Read Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRootGet(options) {
            return localVarFp.readRootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified application.
         * @summary Update application
         * @param {string} id
         * @param {UpdateApplication} updateApplication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(id, updateApplication, options) {
            return localVarFp.updateApplication(id, updateApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specifed conversation.
         * @summary Update conversation
         * @param {string} id
         * @param {UpdateConversation} updateConversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(id, updateConversation, options) {
            return localVarFp.updateConversation(id, updateConversation, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChariotApi - object-oriented interface
 * @export
 * @class ChariotApi
 * @extends {BaseAPI}
 */
class ChariotApi extends base_1.BaseAPI {
    /**
     * Creates a new application with the specified settings.
     * @summary Create application
     * @param {CreateApplication} createApplication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    createApplication(createApplication, options) {
        return exports.ChariotApiFp(this.configuration).createApplication(createApplication, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates or continues an existing conversation. If `conversation_id` is provided, the conversation will be continued.  Otherwise, a new conversation will be created.  If a new conversation is created, the `conversation_id` will be returned in the response. You can use this id to continue the conversation.  The `messages` array is automatically updated for each request/response, so you don\'t need to maintain any message history locally.  To stream the output, set `stream:true` in the request body. The reponse will use [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) to stream new message chunks as they are generated.  For more information on how to stream messages in your application, see our guide on [streaming conversations](/guides/streaming-conversations).
     * @summary Create or continue conversation
     * @param {CreateOrContinueConversation} createOrContinueConversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    createOrContinueConversation(createOrContinueConversation, options) {
        return exports.ChariotApiFp(this.configuration).createOrContinueConversation(createOrContinueConversation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new source. You can create multiple sources at once by passing an array of sources.
     * @summary Create source
     * @param {Sources} sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    createSource(sources, options) {
        return exports.ChariotApiFp(this.configuration).createSource(sources, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes an application and all related conversations and sources. This cannot be undone.
     * @summary Delete application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    deleteApplication(id, options) {
        return exports.ChariotApiFp(this.configuration).deleteApplication(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes all sources and related embeddings for the specified application. This cannot be undone.
     * @summary Delete application sources
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    deleteApplicationSources(id, options) {
        return exports.ChariotApiFp(this.configuration).deleteApplicationSources(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes a conversation and all related messages. This cannot be undone.
     * @summary Delete conversation
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    deleteConversationConversationsIdDelete(id, options) {
        return exports.ChariotApiFp(this.configuration).deleteConversationConversationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Permanently deletes the specified source. This cannot be undone.
     * @summary Delete source
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    deleteSource(id, options) {
        return exports.ChariotApiFp(this.configuration).deleteSource(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single application.
     * @summary Get application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    getApplication(id, options) {
        return exports.ChariotApiFp(this.configuration).getApplication(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single conversation, including all messages.
     * @summary Get conversation
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    getConversation(id, options) {
        return exports.ChariotApiFp(this.configuration).getConversation(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single source.
     * @summary Get source
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    getSource(id, options) {
        return exports.ChariotApiFp(this.configuration).getSource(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all conversations for an application. Does not include conversation messages. To get messages, use the [conversations](/api-reference/conversations#get-conversation) endpoint and get the conversation by id.
     * @summary List application conversations
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    listApplicationConversations(id, options) {
        return exports.ChariotApiFp(this.configuration).listApplicationConversations(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all sources associated with the specified application.
     * @summary List application sources
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    listApplicationSources(id, options) {
        return exports.ChariotApiFp(this.configuration).listApplicationSources(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of your applications.
     * @summary List applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    listApplications(options) {
        return exports.ChariotApiFp(this.configuration).listApplications(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all conversations for your account. This endpoint does not include messages for the conversations. To get messages, retrieve the [conversation by its id](/api-reference/conversations#get-conversation).
     * @summary List conversations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    listConversations(options) {
        return exports.ChariotApiFp(this.configuration).listConversations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all sources for your account. To get a list of all sources for an application, include the `application_id` query parameter.
     * @summary List sources
     * @param {string} [applicationId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    listSources(applicationId, options) {
        return exports.ChariotApiFp(this.configuration).listSources(applicationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Read Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    readRootGet(options) {
        return exports.ChariotApiFp(this.configuration).readRootGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the specified application.
     * @summary Update application
     * @param {string} id
     * @param {UpdateApplication} updateApplication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    updateApplication(id, updateApplication, options) {
        return exports.ChariotApiFp(this.configuration).updateApplication(id, updateApplication, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the specifed conversation.
     * @summary Update conversation
     * @param {string} id
     * @param {UpdateConversation} updateConversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChariotApi
     */
    updateConversation(id, updateConversation, options) {
        return exports.ChariotApiFp(this.configuration).updateConversation(id, updateConversation, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChariotApi = ChariotApi;
